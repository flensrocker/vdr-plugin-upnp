<%args>
objectID;
int resourceID = 0;
</%args>
<%pre>
#include <string>
#include <stdint.h>
#include <limits>
#include <boost/shared_ptr.hpp>
#include "../include/tools.h"
#include "../include/media/mediaManager.h"
#include "../include/server.h"

#include <tnt/httpreply.h>
#include <tnt/httprequest.h>
#include <tnt/http.h>

using namespace upnp;
</%pre>
<#
int doRequest(tnt::HttpReply reply, tnt::HttpRequest request, std::string objectID, int resourceID) {
#>
<%cpp>
  if(objectID.empty()){
    reply.out() << "Object ID missing";
    return HTTP_BAD_REQUEST;
  }

  cMediaServer* server = cMediaServer::GetInstance();
  cMediaManager& manager = server->GetManager();
  boost::shared_ptr<cResourceStreamer> streamer(manager.GetResourceStreamer(objectID, resourceID));

  if(!streamer.get()){
    reply.out() << "Object ID not found or invalid";
    return HTTP_NOT_FOUND;
  }

  int code = HTTP_OK;

  //reply.setKeepAliveHeader();
  reply.setContentType(streamer->GetContentType());
  reply.setHeader("friendlyName.dlna.org  ", server->GetServerDescription().friendlyName);
  reply.setHeader("contentFeatures.dlna.org  ", streamer->GetContentFeatures());
  reply.setHeader("transferMode.dlna.org  ", streamer->GetTransferMode(reply.getHeader("transferMode.dlna.org")));

  unsigned long from = 0, to = 0, contentLength = streamer->GetContentLength(), length = contentLength;
  bool hasRange = false;

  if(contentLength > 0){
    reply.setContentLengthHeader(contentLength);
    if(streamer->Seekable()) reply.setHeader("Accept-Ranges  ", "bytes");

    if(request.hasHeader("Range:")){
      std::string rangeRequest = request.getHeader("Range:");
      if(rangeRequest.find("bytes=",0) == 0){
        unsigned int minus = rangeRequest.find_first_of('-',6);
        if(minus != std::string::npos){
          from  = atoi(rangeRequest.substr(6, minus - 6).c_str());
          to = atoi(rangeRequest.substr(minus + 1).c_str());
          if(from){
            // If range is off the road, reset it to correct values.
            if(from <= 0 || from > contentLength) from = 0;
            if(to <= 0 || to > contentLength) to = contentLength;
            length = to - from;
            hasRange = true;

            if(request.isMethodHEAD()){
              std::stringstream contentRangeHeader;
              contentRangeHeader << "bytes " << from << "-" << to << "/" << contentLength;
              reply.setHeader("Content-Range  ", contentRangeHeader.str());
            }
          }
        }
      }
    }
  }

  if(!request.isMethodHEAD()){

    if(!streamer->Open()){
      code = HTTP_INTERNAL_SERVER_ERROR;
      goto ret;
    }

    ssize_t bytesRead = 0;

    if(hasRange && streamer->Seekable() && contentLength > 0){

      if(!streamer->Seek(from, SEEK_SET)){
        code = HTTP_INTERNAL_SERVER_ERROR;
        goto close;
      }

      if(length > MB(1)) length = MB(1);

      char buffer[length];
      if((bytesRead = streamer->Read(buffer, length)) > 0){
        std::stringstream ss;
        ss << "bytes " << from << "-" << from + bytesRead << "/" << contentLength;
        reply.setHeader("Content-Range  ", ss.str());
        reply.setContentLengthHeader(bytesRead);
        code = HTTP_PARTIAL_CONTENT;
        reply.out().write(buffer, bytesRead);
        if (!reply.out()) {
          code = HTTP_GONE;
          goto close;
        }
      }
      
    } else {
      reply.setDirectMode();
      char buffer[KB(20)];
      while ((bytesRead = streamer->Read(buffer, KB(20))) > 0) {
        reply.out().write(buffer, bytesRead);
        if (!reply.out()) {
          code = HTTP_GONE;
          goto close;
        }
      }
    }
  } else {
    goto ret;
  }

  close:
  streamer->Close();
  ret:
  reply.out() << std::flush;
  return code;
</%cpp>
<#
}
#>
